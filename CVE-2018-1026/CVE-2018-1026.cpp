#include "stdafx.h"
#include <iostream>
#include <windows.h>
#include <string>
#include <fstream>
using namespace std;
char *exec(const char* cmd);
void remove_all_chars(char* str, char c);
struct Version {
	Version(std::string versionStr) {
		sscanf_s(versionStr.c_str(), "%d.%d.%d.%d", &major, &minor, &revision, &build);
		//remember to use  versionStr.c_str() if using C functions like sscanf or strtok

	}
										 // could and perhaps should be a free function
	bool operator<(const Version &otherVersion)
	{
		if (major < otherVersion.major)
			return true;
		if (minor < otherVersion.minor)
			return true;
		if (revision < otherVersion.revision)
			return true;
		if (build < otherVersion.build)
			return true;
		if (major == otherVersion.major && minor == otherVersion.minor && revision == otherVersion.revision && build == otherVersion.build)
			return true;
		return false;
	}
	int major, minor, revision, build;
};
int main(void)
{

	DWORD mydrives = 100;
	char lpBuffer[100];
	DWORD test;
	test = GetLogicalDriveStrings(mydrives, (LPWSTR)lpBuffer);

	string myString;
	myString.assign("SET PATH = C:\Windows\System32\wbem\;%PATH%; & wmic /output:");	myString.append(&lpBuffer[0]);	myString.append(":\\InstallList.txt product get name,version");
	cout << "Please wait..." << endl;
	//char * installed_app = exec(myString.c_str());

	myString.assign(&lpBuffer[0]);	myString.append(":/InstallList.txt");
	ifstream app_file;
	app_file.open(myString);
	char name[255];
	bool flag[] = { false,false,false };
	char * package_result;

	while (!app_file.eof())
	{
		app_file.getline(name,255);
		remove_all_chars(name, '\0');
		//Office 2016
		if (strstr(name, "Office") && strstr(name,"2016") && flag[0] == false){
			flag[0] = true;
			cout << "You have installed Office 2016, and this version is vulnerable!" << endl;
			package_result = exec("SET PATH=C:\Windows\System32\wbem\;%PATH%; wmic qfe | find \"4018319\"");
			if (package_result != "")
			{
				cout << "You have installed the patch for cve-2018-1026 vulnerability." << endl;
			}
		}
		//Office 2013
		if (strstr(name, "Office") && strstr(name, "2013") && flag[1]==false) {
			flag[1] = true;
			myString.assign(name);	int i = myString.find_first_of(' ');	for (; name[i] == ' ' && name[i+1]!=' ' || name[i]!=' '; i++);		remove_all_chars(&name[i], ' ');	myString = myString.assign(&name[i]);
			
			if (Version("15.0.4569.1506") < Version(myString)) {
				cout << "You have installed Office 2013 SP1, and this SP has CVE-2018-1026 vulnerability!" << endl;
				package_result = exec("SET PATH=C:\Windows\System32\wbem\;%PATH%; wmic qfe | find \"4018288\"");
				if (package_result != "")
				{
					cout << "You have installed the patch for cve-2018-1026 vulnerability." << endl;
				}
			}
			else
				cout << "You have installed Office 2013 but haven't install SP1 so you are safe against CVE-2018-1026." << endl;
		}
		//Office 2016 Click-to-Run
		if (strstr(name, "Office") && strstr(name, "2016") && !strstr(name,"Click-to-run") && flag[2] == false) {
			flag[2] = true;
			cout << "You have installed Office 2016 Click-to-Run, and this version is vulnerable!" << endl;
			package_result = exec("SET PATH=C:\Windows\System32\wbem\;%PATH%; wmic qfe | find \"4018319\"");
			if (package_result != "")
			{
				cout << "You have installed the patch for cve-2018-1026 vulnerability." << endl;
			}
		}
	}
	

	return 0;
}
char* exec(const char* cmd) {
	char buffer[256];
	char *result = new char[256 * 10]{ '\0' };
	FILE* pipe = _popen(cmd, "r");
	if (!pipe) throw std::runtime_error("popen() failed!");
	try {
		while (!feof(pipe)) {
			if (fgets(buffer, 128, pipe) != NULL)
				strcat_s(result, 128, buffer);
		}
	}
	catch (...) {
		_pclose(pipe);
		throw;
	}
	_pclose(pipe);
	return result;
}

void remove_all_chars(char* str, char c) {
	char *pr = str, *pw = str;
	while (*pr!='\r') {
		*pw = *pr++;
		pw += (*pw != c);
	}
	*pw = '\0';
}



